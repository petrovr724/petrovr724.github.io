/ *! WOW - v1.1.2 - 19 августа 2015 г.
* Авторские права (c) 2015 Matthieu Aussaguel; Лицензированный MIT * / ( function ( ) { var  a , b , c , d , e , f = function ( a , b ) { return  function ( ) { return  a . Apply ( b , arguments ) } } , g = [ ] . indexOf || функция ( a) { for ( var  b = 0 , c = this . length ; c > b ; b ++ ) if ( b  в  этом && this [ b ] === a ) return  b ; return - 1 } ; б = функция ( ) { функция  ( ) { } вернуться . прототип . extension = функция ( a , b ) { var  c , d ; для ( c  в  b ) d = b [ c ] , null == a [ c ] && ( a [ c ] = d ) ; return  a } , a . прототип . isMobile = функция( а ) { return / Android | webOS | iPhone | iPad | iPod | BlackBerry | IEMobile | Opera Mini / i . test ( a ) } , а . прототип . createEvent = функция ( a , b , c , d ) { var  e ; return  null == b && ( b= ! 1 ) , null == c && ( c = ! 1 ) , null == d && ( d = null ) , null ! = Документ . createEvent ? ( e = document . createEvent ( "CustomEvent" ) , e . initCustomEvent ( a , b , c , d ) ): null ! = документ . createEventObject ? ( e = document . createEventObject ( ) , e . eventType = a ) : e . eventName = a , e } , a . прототип . emitEvent = function ( a , b ) { return  null ! = a . dispatchEvent ? а. dispatchEvent ( b ) : b  in ( null ! = a ) ? a [ b ] ( ) : "on" + b  in ( null ! = a ) ? a [ "on" + b ] ( ) : void  0 } , a . прототип . addEvent = функция ( a , b , c) { вернуть  ноль ! = а . addEventListener ? а . addEventListener ( б , с , ! 1 ) : нулевой =! . attachEvent ? а . attachEvent ( "on" + b , c ) : a [ b ] = c } , a . прототип . removeEvent = функция (a , b , c ) { return  null ! = a . removeEventListener ? а . removeEventListener ( б , с , ! 1 ) : нулевой =! . detachEvent ? а . detachEvent ( "on" + b , c ) : удалить a [ b ] } , a . прототип . innerHeight = function ( ) { вернуть "innerHeight" в  окне ? окно . innerHeight : документ . documentElement . clientHeight } , a } ( ) , c = this . WeakMap || это . MozWeakMap || ( c = function ( ) { function  a ( ) { this . keys= [ ] , это . значения = [ ] } возвращают  . прототип . получить = функция ( а ) { var b , c , d , e , f ; for ( f = this . keys , b = d = 0 , e = f . length ; e > d ; b = ++ d ) if ( c = f [ b ] , c === a ) вернуть  это . values [ b ] } , a . прототип . set = function ( a , b ) { var  c , d , e , f , g ; for ( g = this . keys, c = e = 0 , f = g . длина ; f > e ; c = ++ e ) if ( d = g [ c ] , d === a ) return  void ( this . values [ c ] = b ) ; верни  это . ключи . толкать ( а ) ,это . ценности . push ( b ) } , a } ( ) ) , a = это . MutationObserver || это . WebkitMutationObserver || это . MozMutationObserver || ( a = function ( ) { function  a ( ) { "undefined" ! = typeof  console && null ! == console && console. warn ( "MutationObserver не поддерживается вашим браузером." ) , "undefined" ! = typeof  console && null ! == console && console . warn ( "WOW.js не может обнаружить мутации dom, вызовите .sync () после загрузки нового содержимого." ) } верните  a . notSupported = ! 0 , а . прототип . наблюдать = функция ( ) { } , a } () ) , d = это . getComputedStyle || function ( a ) { вернуть  это . getPropertyValue = функция ( б ) { var  c ; return "float" === b && ( b = "styleFloat" ) , e . тест ( б ) && б . replace ( e , function ( a, б ) { возврат  б . toUpperCase ( ) } ) , ( null ! = ( c = a . currentStyle ) ? c [ b ] : void  0 ) || null } , this } , e = / ( \ - ( [ az ] ) { 1 } ) / g , this .WOW = function ( ) { function  e ( a ) { null == a && ( a = { } ) , это . scrollCallback = f ( this . scrollCallback , this ) , this . scrollHandler = f ( this . scrollHandler , this ) , this . resetAnimation =f ( this . resetAnimation , this ) , this . start = f ( это . начало , это ) , this . scrolled = ! 0 , это . config = это . util ( ) . extension ( a , this . defaults ) , null ! = a . scrollContainer &&( this . config . scrollContainer = document . querySelector ( a . scrollContainer ) ) , this . animationNameCache = new  c , this . wowEvent = это . util ( ) . createEvent ( this . config . boxClass ) } вернуть  e . прототип . defaults = {boxClass : "вау" , animateClass : "animated" , смещение : 0 , mobile :! 0 , live :! 0 , обратный вызов : null , scrollContainer : null } , e . прототип . инициализация = функция ( ) { var  a ; верни  это . element = window . документ .documentElement , "interactive" === ( a = document . readyState ) || "полный" === а ? это . start ( ) : это . util ( ) . addEvent ( документ , "DOMContentLoaded" , this . start ) , this . finish = [ ] } , e . прототип . Начните= функция ( ) { var  b , c , d , e ; if ( this . Stop = ! 1 , this . Boxs = function ( ) { var  a , c , d , e ; for ( d = this . element . querySelectorAll ( "." + this . config .boxClass ) , e = [ ] , a = 0 , c = d . длина ; с > а ; a ++ ) b = d [ a ] , e . толкать ( б ) ; return  e } . позвони ( это ) , это . all = function ( ) { var  a, в , г , д ; for ( d = this . box , e = [ ] , a = 0 , c = d . length ; c > a ; a ++ ) b = d [ a ] , e . толкать ( б ) ; return  e } . позвони ( это ), это . коробки . length ) if ( this . disabled ( ) ) this . resetStyle ( ) ; else  for ( e = this . box , c = 0 , d = e . length ; d > c ; c ++ ) b = e [ c ] , this .ApplyStyle ( б , ! 0 ) ; верни  это . отключен ( ) || ( this . util ( ) . addEvent ( this . config . scrollContainer || окно , «прокрутка» , this . scrollHandler ) , this . util ( ) . addEvent ( окно , «изменение размера» , this .scrollHandler ) , this . interval = setInterval ( this . scrollCallback , 50 ) ) , this . config . жить ? new  a ( function ( a ) { return  function ( b ) { var  c , d , e , f , g ; for ( g = [ ] ,c = 0 , d = b . длина ; d > c ; c ++ ) f = b [ c ] , g . push ( function ( ) { var  a , b , c , d ; for ( c = f . addedNodes || [ ] , d = [ ] , a =0 , b = c . длина ; б > а ; a ++ ) e = c [ a ] , d . push ( this . doSync ( e ) ) ; return  d } . звонок ( а ) ) ; return  g } } ( это ) ) . соблюдать ( документ .тело , { childList :! 0 , поддерево :! 0 } ) : void  0 } , e . прототип . stop = function ( ) { вернуть  это . остановился = ! 0 , это . util ( ) . removeEvent ( this . config . scrollContainer || окно , "прокрутка" ,это . scrollHandler ) , this . util ( ) . removeEvent ( окно , "изменить размер" , this . scrollHandler ) , null ! = this . интервал ? clearInterval ( this . interval ) : void  0 } , e . прототип . синхронизация = функция ( ) { возвращают  .notSupported ? это . doSync ( this . element ) : void  0 } , e . прототип . doSync = функция ( а ) { var  b , c , d , e , f ; if ( null == a && ( a = this . element ) , 1 === a .nodeType ) { for ( a = a . parentNode || a , e = a . querySelectorAll ( "." + this . config . boxClass ) , f = [ ] , c = 0 , d = e . length ; d > c ; c ++ ) b = e [ c ] ,г . call ( this . all , b ) < 0 ? ( Это . Коробки . Нажим ( б ) , это . Все . Нажим ( б ) , это . Остановлено || это . Отключил ( ) ? Это . ResetStyle ( ) : это . ApplyStyle ( б , ! 0) , ф . push ( this . scrolled = ! 0 ) ) : f . push ( void  0 ) ; return  f } } , e . прототип . show = function ( a ) { верните  это . applyStyle ( а ) , а . className = a . className +"" + это . config . animateClass , null ! = это . config . обратный вызов && this . config . обратный вызов ( а ) , это . util ( ) . emitEvent ( a , this . wowEvent ) , this . util ( ) . addEvent ( a , "animationend" , это. resetAnimation ) , это . util ( ) . addEvent ( a , "oanimationend" , this . resetAnimation ) , this . util ( ) . addEvent ( a , "webkitAnimationEnd" , this . resetAnimation ) , this . util ( ) . addEvent ( a , "MSAnimationEnd" , это. resetAnimation ) , a } , e . прототип . applyStyle = функция ( a , b ) { var  c , d , e ; вернуть  d = a . getAttribute ( "дата-вау-продолжительность" ) , c = a . getAttribute ( "данные-вау-задержка" ) , e = a . getAttribute ("данные-вау-итерация" ) , это . animate ( function ( f ) { return  function ( ) { return  f . customStyle ( a , b , d , c , e ) } } ( this ) ) } , e . прототип . animate = function ( ) { вернуть requestAnimationFrame в окно ? function ( a ) { окно возврата  . requestAnimationFrame ( a ) } : function ( a ) { return a ( ) } } ( ) , e . прототип . resetStyle = функция ( ) { var a , b , c , d , e ; для ( d =  это . коробки , e = [ ] , b = 0 , c = d . длина ; c > b ; b ++ ) a = d [ b ] , e . push ( a . style . visibility = "visible" ) ; return  e } , e . прототип . resetAnimation =функция ( а ) { var  b ; вернуться  . тип . toLowerCase ( ) . indexOf ( "animationend" ) > = 0 ? ( b = a . target || a . srcElement , b . className = b . className . replace ( this . config . animateClass , "" ) .trim ( ) ) : void  0 } , e . прототип . customStyle = function ( a , b , c , d , e ) { вернуть  b && this . cacheAnimationName ( а ) , а . стиль . видимость = b ? "скрытый" : "видимый" , c && это .vendorSet ( a . style , { animationDuration : c } ) , d && this . vendorSet ( a . style , { animationDelay : d } ) , e && this . vendorSet ( a . style , { animationIterationCount : e } ) , this . vendorSet ( a .стиль , { animationName : b ? «нет» : это . cachedAnimationName ( a ) } ) , a } , e . прототип . vendors = [ "moz" , "webkit" ] , e . прототип . vendorSet = функция ( a , b ) { var  c , d , e , f; d = [ ] ; для ( c  в  b ) e = b [ c ] , a [ "" + c ] = e , d . push ( function ( ) { var  b , d , g , h ; for ( g = this . vendors , h = [ ] , b= 0 , d = g . длина ; d > b ; b ++ ) f = g [ b ] , h . push ( a [ "" + f + c . charAt ( 0 ) . toUpperCase ( ) + c . substr ( 1 ) ] = e ) ; return  h }. вызов ( это ) ) ; return  d } , e . прототип . vendorCSS = функция ( a , b ) { var  c , e , f , g , h , i ; для ( h = d ( a ) , g = h . getPropertyCSSValue ( b ) , f =это . поставщики , c = 0 , e = f . длина ; е > с ; c ++ ) i = f [ c ] , g = g || ч . getPropertyCSSValue ( "-" + i + "-" + b ) ; return  g } , e . прототип . animationName = функция( а ) { var  b ; попробуйте { b = this . vendorCSS ( a , "имя-анимации" ) . cssText } catch ( c ) { b = d ( a ) . getPropertyValue ( "имя-анимации" ) } вернуть "нет" === b ? "" : b } , e . прототип .cacheAnimationName = function ( a ) { верните  это . animationNameCache . set ( a , this . animationName ( a ) ) } , e . прототип . cachedAnimationName = function ( a ) { вернуть  это . animationNameCache . get ( a ) } , e . прототип .scrollHandler = function ( ) { вернуть  это . scrolled = ! 0 } , эл . прототип . scrollCallback = функция ( ) { var  a ; вернуться ! это . прокручивается || ( this . scrolled = ! 1 , this . box = function ( ) { var  b ,в , г , д ; for ( d = this . box , e = [ ] , b = 0 , c = d . length ; c > b ; b ++ ) a = d [ b ] , a && ( this . isVisible ( a ) ? this . показать ( а ): e . нажать ( а ) ) ; return  e } . позвони ( это ) , это . коробки . длина || это . config . жить ) ? пустота  0 : это . stop ( ) } , e . прототип . offsetTop = function ( a ) { for ( var  b; пусто  0 === а . offsetTop ; ) а = а . parentNode ; for ( b = a . offsetTop ; a = a . offsetParent ; ) b + = a . offsetTop ; return  b } , e . прототип . isVisible = функция ( a ) { var  b , c, г , д , е ; вернуть  c = a . getAttribute ( "data-wow-offset" ) || это . config . смещение , f = это . config . scrollContainer && this . config . scrollContainer . scrollTop || окно . pageYOffset , e = f + Math . мин ( это. элемент . clientHeight , это . util ( ) . innerHeight ( ) ) - c , d = это . offsetTop ( a ) , b = d + a . clientHeight , e > = d && b > = f } , e . прототип . util = function ( ) { return null ! = это . _util ? это . _util : это . _util = new  b } , e . прототип . disabled = function ( ) { return ! это . config . мобильный && this . util ( ) . isMobile ( навигатор . userAgent ) } , e } ( )} ) . вызов ( это ) ;